% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
%                            Recomendaciones
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------

\chapter{Desarrollo del proyecto}
% ------------------------------------------------------------------------
\noindent En este Capítulo se presentará como fue desarrollado el proyecto.
% ------------------------------------------------------------------------ 
\section{Ambientación tecnológica}
\subsection{Investigaci\'on fundamentos te\'oricos relacionados con el proyecto (Tecnolog\'ias y est\'andares)}
Durante esta primera fase se investigó el estado del arte en cloud computing para poder identificar los conceptos comunes en las diferentes arquitecturas cloud enfocadas a IoT. De esta primera fase se encontró la gestión de contenedores como factor común por lo cual la investigación posterior siguió este enfoque. Posteriormente se identificaron las tecnologías mas populares en IoT.

\begin{table}[H]
	\begin{minipage}{1\textwidth}
		\caption[Tecnologías disponibles en el mercado]{ \raggedright Tecnologías disponibles en el mercado}
		\label{tabla:Tecnologías disponibles en el mercado}
		\begin{center}
			\begin{tabular}{ p{5cm}   p{5cm}  p{5cm}  }
				\hline
				Sistema Operativo & Container Runtime & Orquestador de contenedores \\
				\hline
				CentOS & Cri-O & Apache Mesos \\
				CoreOS & Docker & Docker Swarm \\
				Red Hat Enterprise Linux & Linux VServer & Kontena \\
				Oracle Linux & LXD & Kubernetes \\
				Ubuntu Server & Rkt  & Nomad \\
				Windows Server & Windows Containers & Openstack Magnum x
				\\ \hline
			\end{tabular}
		\end{center}
	\end{minipage}
\end{table}

A medida que se desarrolló en proyecto, nuevas tecnologías fueron añadidas al stack pero ya de eso se hablará mas adelante en el documento.

A medida que se desarrolló en proyecto, nuevas tecnologías fueron añadidas al stack pero ya de eso se hablará mas adelante en el documento.

\subsection{Estudio}
Durante esta etapa se realizó una revisión general sobre cada una de las tecnologías, lo cual sirvió de base para la definir los criterios de selección para realizar un primer filtro sobre las tecnologías a usar en la infraestructura en la siguiente etapa.

\begin{itemize}
	\item Licencia
	\item Stacks
	\item Soporte
	\item Uso libre en producción
\end{itemize}



\subsection{Sondeo}
Durante esta etapa se aplicaron los diferentes criterios entre cada una de las tecnologías y se consolido está información en las tablas \ref{tabla:Sondeo de selección: Sistema Operativo}, \ref{tabla:Sondeo de selección: Container Runtime} y \ref{tabla:Sondeo de selección: Orquestador de contenedores}.
\begin{table}[H]
	\begin{minipage}{1\textwidth}
		\caption[Sondeo de selección: Sistema Operativo]{ \raggedright Sondeo de selección: Sistema Operativo}
		\label{tabla:Sondeo de selección: Sistema Operativo}
		\begin{center}
			\begin{tabular}{ p{3cm}   p{3cm}  p{2cm}  p{3cm}  p{4cm}  }
				\hline
				S. Operativo & Licencia & Stacks & Soporte & Gratis en producción \\  \hline
				CentOS & GPL & 1.85K & Comunidad & Si
				\\ 
				CoreOS & Apache 2.0 & 164 & Comunidad & Si
				\\ 
				RHEL\footnote{Red Hat Enterprise Linux} & GPL\footnote{Solo para efectos de desarrollo, en producción se cobra una tarifa.} & - & Privado & No
				\\ 
				Oracle Linux & GPL & - & Privado & Si
				\\ 
				Ubuntu Server & GPL & 9.1k & Hibrido\footnote{Posibilidad de adquirir soporte pago pero posee una gran comunidad que lo respalda.} & Si
				\\ 
				Windows Server & Múltiple\footnote{Microsoft provee diferentes licencias según los servicios solicitados.} & 3.4k & Privado & No
				\\ \hline
			\end{tabular}
		\end{center}
		{La cantidad de stacks fueron tomados de: \url{https://stackshare.io/}}
	\end{minipage}
\end{table}


\begin{table}[H]
	\begin{minipage}{1\textwidth}
		\caption[Sondeo de selección: Container Runtime]{ \raggedright Sondeo de selección: Container Runtime}
		\label{tabla:Sondeo de selección: Container Runtime}
		\begin{center}
			\begin{tabular}{ p{3cm}  p{3cm} p{2cm}  p{4cm}  p{3cm}  }
				\hline
				Container Runtime & Licencia & Stacks & Soporte & Uso libre en producción \\ \hline
				Cri-O & Apache 2.0 & - & Comunidad & Si
				\\ 
				Docker & Apache 2.0 & 16.6K & Comunidad/Privado & Si
				\\ 
				Linux VServer & GPL & - & Comunidad & Si
				\\ 
				LXD & Apache 2.0 & 39 & Comunidad & Si
				\\ 
				Rkt & Apache 2.0 & 21 & Comunidad & Si
				\\
				Windows Containers & SaaS & - & Privado & No
				\\ \hline
			\end{tabular}
		\end{center}
		{La cantidad de stacks fueron tomados de:
			\url{https://stackshare.io/}}
	\end{minipage}
\end{table}


\begin{table}[H]
	\begin{minipage}{1\textwidth}
		\caption[Sondeo de selección: Orquestador de contenedores]{ \raggedright Sondeo de selección: Orquestador de contenedores}
		\label{tabla:Sondeo de selección: Orquestador de contenedores}
		\begin{center}
			\begin{tabular}{ p{3cm}   p{3cm}  p{2cm}  p{4cm}  p{3cm}  }
				\hline
				Orquestador & Licencia & Stacks & Soporte & Gratis en producción \\ \hline
				Apache Mesos &  Apache 2.0 & 177 & Comunidad & Si 
				\\ \hline
				Docker Swarm & Apache 2.0  
				\footnote{Algunos componentes se encuentran bajo la licencia Apache 2.0 y otros bajo Docker Enterprise 2.0 y 2.1} & 319 & Comunidad/Privado & Si\footnote{Si se desea utilizar Docker Trusted Registry o Universal Control Pane, si es necesario adquirir una licencia.}
				\\ 
				Kontena & Apache 2.0 & 7 & Comunidad & Si
				\\ 
				Kubernetes & Apache 2.0 & 4.25k & Comunidad & Si 
				\\ 
				Nomad & Mozilla 2.0 & 56 & Comunidad/Privado & Si \footnote{HashiCorp ofrece planes pagos con funcionalidades adicionales}
				\\ 
				Docker Compose & Apache 2.0 & 3.19k\footnote{Se utilizó la cantidad de stacks de Openstack} & Comunidad/Privado & Si 
				\\ \hline
			\end{tabular}
		\end{center}
		{La cantidad de stacks fueron tomados de:
			\url{https://stackshare.io/}}
	\end{minipage}
\end{table}


\section{Definición de arquitectura de infraestructura cloud}

\subsection{Definici\'on requisitos}
Se identificaron las características que debe tener una infraestructura, haciendo uso de las características esenciales de un modelo de cloud computing \citep{MELL2011} y los requerimientos que demanda una arquitectura de microservicios.
\begin{itemize}
	\item Autoservicio sobre demanda.
	\item Amplio acceso a la red.
	\item Agrupación de recursos.
	\item Elasticidad.
	\item Servicio medido.
	\item Políglota.
	\item Soporte de microservicios
	\item Monitoreo.
	\item Soporte para DevOps.
	\item Seguridad.
	\item Tolerancia a fallos.
\end{itemize}
\subsection{Definici\'on m\'etricas}
Teniendo en cuenta los requisitos, se comparan las siguientes métricas en un escenario monolítico y en un escenario distribuido variado.
\begin{itemize}
	\item Porcentaje de solicitudes fallidas durante un despliegue.
	\item Tiempo promedio de respuesta para 1000 solicitudes por minuto.
	\item Número máximo de solicitudes por minuto.
	\item Porcentaje de solicitudes fallidas para 3500 solicitudes por minuto.
	\item Porcentaje de solicitudes fallidas para 1000 solicitudes por minuto durante el fallo de un nodo.
\end{itemize}
\subsection{Definici\'on pruebas}
Para las pruebas, se plantearon los siguientes escenarios:
\begin{enumerate}
	\item Monolítico.
	\item Escenario distribuido con 1 instancia del backend.
	\item Escenario distribuido con 2 instancias del backend.
	\item Escenario distribuido con 3 instancias del backend.
\end{enumerate}

Los siguientes métodos fueron seleccionados para aplicar las pruebas.

\begin{table}[H]
	\begin{minipage}{1\textwidth}
		\caption[Métodos usados en las pruebas sobre el prototipo]{ \raggedright Métodos usados en las pruebas sobre el prototipo}
		\label{tabla:Métodos usados en las pruebas sobre el prototipo}
		\begin{center}
			\begin{tabular}{| p{5cm}  | p{5cm} | p{5cm} | }
				\hline
				Método HTTP & Ruta & Descripción \\ \hline
				POST & /users/user & Crea un nuevo usuario en la base de datos \\ \hline
				POST & /users/authentication & Verifica las credenciales de un usuario \\ \hline
				PUT & /users/user & Actualiza un usuario en la base de datos \\ \hline
				DELETE & /users/user & Elimina un usuario en la base de datos \\ \hline
			\end{tabular}
		\end{center}
	\end{minipage}
\end{table}

Cada una de las pruebas busca medir cada una de las diferentes métricas (sección 5.2.2) para los 4 escenarios planteados durante 10 minutos.

\begin{enumerate}
	\item {\textbf{Porcentaje de solicitudes fallidas durante un despliegue}} La prueba consiste en realizar un cambio de versión del backend mientras se están recibiendo solicitudes. 
	Para el ambiente monolítico, se tendrá un script que detenga una versión y arranque una nueva con el fin de evitar el error humano.
	Para el ambiente distribuido se hará uso del Continuous Deployment en la arquitectura propuesta.
	
	\item {\textbf{Tiempo promedio de respuesta para 1000 solicitudes por minuto}} La prueba consiste en enviar 1000 solicitudes por un minuto a cada uno de los ambientes.
	
	\item {\textbf{Número máximo de solicitudes por minuto sin solicitudes fallidas}} La prueba consiste en aplicar pruebas de estrés sobre los diferentes ambientes para encontrar la cantidad de solicitudes por minuto que pueden soportar sin presentar solicitudes fallidas.
	
	\item{\textbf{Porcentaje de solicitudes fallidas para 1000 solicitudes por minuto}} La prueba consiste en enviar 1000 solicitudes por minuto y ver que porcentaje falló en cada uno de los ambientes.
	
	\item{\textbf{Cantidad de solicitudes fallidas para 1000 solicitudes por minuto durante el fallo de un nodo}} La prueba consiste en apagar un nodo de forma abrupta mientras se están recibiendo 1000 solicitudes y ver como se ven afectados los ambientes. En el caso del ambiente monolítico, se reiniciará el servidor.
\end{enumerate}

Para generar un dataset para las pruebas, se utilizó Mockaroo\footnote{\href{https://www.mockaroo.com/}{https://www.mockaroo.com/}} (Ver apéndice %\ref{appendix:Dataset generado para pruebas}).


\subsection{Definici\'on arquitectura e infraestructura}

La elección de los componentes de la infraestructura fue hecha teniendo en cuenta el impacto de las diferentes tecnologías en el mercado. Como podemos ver en la tabla \ref{tabla:Sondeo de selección: Orquestador de contenedores}, \textbf{Kubernetes} es la opción mas popular, además de tener una licencia que nos permite hacer uso gratuito de la herramienta en producción junto a una de las comunidades mas grandes entre las otras opciones estudiadas.

Profundizando sobre Kubernetes, apareció \textbf{Openshift Origin} \citep{OpenshiftArquitectura}, un proyecto de Red Hat que extiende las funcionalidades de Kubernetes. Se revisó la licencia y las ventajas con respecto a Kubernetes, como la seguridad. Finalmente se decidió usar Openshift Origin como plataforma para administrar Kubernetes dentro de la arquitectura.

\textbf{Docker} se seleccionó como container runtime por la popularidad, comunidad y uso libre en producción.

\textbf{CentOS} se seleccionó como sistema operativo fue por la comunidad, madurez y estabilidad que presenta con respecto a las alternativas.

La arquitectura se compone de los siguientes elementos:
\begin{itemize}
	\item \textbf{Reverse proxy: } Es la puerta de entrada al backend. Su función es redirigir las solicitudes entrantes al componente de la capa service correspondiente basado en el endpoint solicitado, de esta forma podemos exponer todos los microservicios como si de un solo se tratase. Se seleccionó  \textbf{Nginx} como proxy reverso por su alto rendimiento y bajo consumo de memoria. \cite{NGINX2017}
	\item \textbf{Service layer: }En esta capa se encuentra una encuentra una abstracción de los pods que nos provea un dominio fijo. Para la infraestructura se escogió usar los objetos \textbf{Kubernetes Services} los cuales nos proveen un nombre de dominio fijo para el acceso a la capa pod además de proveer balanceo de carga en el caso de los componentes que tienen mas de una instancia.
	\item \textbf{Deployment layer: } En esta capa se encuentran los archivos de definición de los elementos de la capa pod. Esta capa se encuentra conectada a un repositorio git por medio de una tecnología de CI/CD de tal forma que cuando los desarrolladores suban un cambio a la rama master del repositorio, se realice todo el proceso de compilado, publicación y actualización de los archivos de despliegue correspondientes. Para la infraestructura, se escogió usar los objetos \textbf{kubernetes deployment}. 
	\item \textbf{Pod layer: } En esta capa se encuentran las instancias efimeras de la arquitectura. Para la arquitectura se escogió usar los objetos \textbf{Kubernetes pods} (Instancias de la capa Openshift deployment) de cada uno de los elementos desplegados. En el caso de los artefactos que poseen mas de una instancia, como es el caso de admin-microservice o data-microservice, Openshift provee la funcionalidad de despliegue canario manteniendo n-1\footnote{n: Número de instancias activas} instancias activas mientras que las nuevas instancias se encuentran listas para recibir solicitudes.
	\item \textbf{Persistence logic layer: } En esta capa se encuentra la conexión lógica con la persistence physical layer. Para la infraestructura se escogió usar los objetos \textbf{Kubernetes Volume}, los cuales conectan los pods con la persistence physical layer\citep{KubernetesVolumes}. Las bases de datos y los brókers de mensajería son los principales artefactos que usan esta capa.
	\item \textbf{Persistence physical Layer}
	En esta capa se encuentra el sistema de archivos para persistir datos en disco. Para el caso de la infraestructura se propone usar \textbf{glusterfs} por que nos permite distribuir de forma redundante los archivos en diferentes nodos, de tal manera que si alguno de los nodos falla, el sistema puede continuar haciendo uso de otro nodo para seguir persistiendo la información.
	\item \textbf{Code repository} 
	Sistema de archivos en el cual se alojará el código fuente. Se seleccionó \textbf{git} como code repository por su popularidad y relevancia en el mercado. Por otra parte, \textbf{Gitlab} se escogió como proveedor por la gran cantidad de herramientas que ofrece para la gestión de proyectos software.
	\item \textbf{CI/CD}
	Entre las herramientas que ofrece \textbf{gitlab} se encuentra un sistema de CI/CD basado en pipelines. La gran ventaja que tiene con respecto a otras alternativas es su sencillez de integración en arquitecturas cloud.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.3\textwidth]{figs/Infraestructura.png}
	\caption{Infraestructura software propuesta.}\label{Infraestructura software propuesta}
\end{figure}

\begin{landscape}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.5\textwidth]{figs/Thesis-Architecture.png}
		\caption{Arquitectura propuesta.}\label{Arquitectura propuesta}
	\end{figure}
\end{landscape}


\section{Prototipado}

\section{Validaci\'on de prototipo}


